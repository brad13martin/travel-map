<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Didius Travel Map — Route-wide Minutes Filter</title>

<!-- Mapbox GL core -->
<link href="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js"></script>

<!-- Directions plugin -->
<link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.js"></script>

<!-- Turf.js for geometry ops -->
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<style>
  html,body{height:100%;margin:0;font-family:system-ui,Inter,Arial}
  #map{height:100vh;width:100%}
  .panel{position:absolute;z-index:3;left:12px;top:12px;background:#fff;padding:10px 12px;border-radius:12px;border:1px solid #e5e7eb;box-shadow:0 6px 20px rgba(0,0,0,.12);display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .panel label{font-size:12px;color:#111827}
  .panel input[type="range"]{width:160px}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:4px 10px;font-size:12px;background:#f8fafc}
  #legend{position:absolute;right:12px;top:12px;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.12);z-index:2}
  #err{position:absolute;left:12px;bottom:12px;background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.12);font-size:12px;max-width:70ch;display:none;z-index:4;white-space:pre-wrap}
  .mapboxgl-ctrl-top-right{margin-top:8px}
</style>
</head>
<body>

<!-- Controls -->
<div class="panel">
  <span class="pill">Within 
    <input id="mins" type="range" min="5" max="60" step="5" value="15" />
    <strong><span id="minsVal">15</span> min</strong>
  </span>
  <span class="pill">
    Mode:
    <label><input type="radio" name="mode" value="driving" checked> Driving</label>
    <label><input type="radio" name="mode" value="walking"> Walking</label>
    <label><input type="radio" name="mode" value="cycling"> Cycling</label>
  </span>
  <button id="applyIso" class="pill" style="cursor:pointer">Apply to route</button>
  <button id="clearIso" class="pill" style="cursor:pointer">Clear</button>
</div>

<div id="map" aria-label="Interactive map"></div>
<div id="legend"></div>
<div id="err"></div>

<script>
// ====== CONFIG ======
mapboxgl.accessToken = 'pk.eyJ1IjoiYnJhZDEzbWFydGluIiwiYSI6ImNta2p6eHI5MzE4YzAzY282aXE4Mjhxc3QifQ.tkosuQGdRkfSMoRVWCakbg';

const STYLE_URL   = 'mapbox://styles/brad13martin/cmkjztnvs001u01qm6lsmeold';
const TILESET_URL = 'mapbox://brad13martin.c1m5hzkh';
const SOURCE_LAYER = 'travelmap_geocoded-5lk8ms';

const DATA_SOURCE_ID = 'places';
const DATA_LAYER_ID  = 'places-points';
const ISO_SOURCE_ID  = 'iso-source';
const ISO_LAYER_FILL = 'iso-fill';
const ISO_LAYER_LINE = 'iso-line';

const MAX_SAMPLES = 12;     // cap Isochrone calls per route
const AVG_SPEED_KMH = {     // rough averages for spacing
  driving: 65,  // ≈ 40 mph
  walking: 5,
  cycling: 18
};

// ====== UI hooks ======
const minsInput = document.getElementById('mins');
const minsVal   = document.getElementById('minsVal');
const applyBtn  = document.getElementById('applyIso');
const clearBtn  = document.getElementById('clearIso');
const errBox    = document.getElementById('err');
minsInput.addEventListener('input', () => minsVal.textContent = minsInput.value);

function showErr(msg){ errBox.style.display='block'; errBox.textContent = msg; }
function clearErr(){ errBox.style.display='none'; errBox.textContent=''; }

// ====== MAP & DIRECTIONS ======
const map = new mapboxgl.Map({
  container: 'map',
  style: STYLE_URL,
  center: [-80, 40],
  zoom: 5
});
map.addControl(new mapboxgl.NavigationControl());
map.on('error', ev => showErr('Mapbox: ' + (ev?.error?.message || JSON.stringify(ev))));

const directions = new MapboxDirections({
  accessToken: mapboxgl.accessToken,
  profile: 'mapbox/driving',
  unit: 'imperial',
  alternatives: true,
  controls: { instructions: false },
  geometries: 'geojson'  // important: we need a LineString back
});
map.addControl(directions, 'top-right');

let currentRouteLine = null;
directions.on('route', e => {
  // store the first route's geometry as a Turf LineString
  try {
    const r = e?.route?.[0];
    if (r && r.geometry && r.geometry.type === 'LineString') {
      currentRouteLine = r.geometry;
    } else if (r && r.geometry && r.geometry.coordinates) {
      currentRouteLine = { type:'LineString', coordinates: r.geometry.coordinates };
    } else {
      currentRouteLine = null;
    }
  } catch { currentRouteLine = null; }
});

// ====== LAYERS ======
map.on('load', () => {
  // Points
  map.addSource(DATA_SOURCE_ID, { type: 'vector', url: TILESET_URL });
  map.addLayer({
    id: DATA_LAYER_ID,
    type: 'circle',
    source: DATA_SOURCE_ID,
    'source-layer': SOURCE_LAYER,
    paint: {
      'circle-radius': 6,
      'circle-color': '#2563eb',
      'circle-stroke-color': '#fff',
      'circle-stroke-width': 1
    }
  });

  // Isochrone shells
  map.addSource(ISO_SOURCE_ID, { type: 'geojson', data: { type:'FeatureCollection', features: [] } });
  map.addLayer({ id: ISO_LAYER_FILL, type: 'fill', source: ISO_SOURCE_ID,
    paint: { 'fill-color': '#10b981', 'fill-opacity': 0.12 } });
  map.addLayer({ id: ISO_LAYER_LINE, type: 'line', source: ISO_SOURCE_ID,
    paint: { 'line-color': '#10b981', 'line-width': 2, 'line-opacity': 0.8 } });

  document.getElementById('legend').innerHTML = `
    <b>Legend</b><br>
    <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#2563eb;margin-right:6px"></span>Place<br>
    <span style="display:inline-block;width:10px;height:10px;background:#10b981;margin-right:6px"></span>Reachable area
  `;
});

// ====== ISOCHRONE HELPERS ======
async function fetchIso(lng, lat, minutes, profile){
  const url = new URL(`https://api.mapbox.com/isochrone/v1/mapbox/${profile}/${lng},${lat}`);
  url.searchParams.set('contours_minutes', String(minutes));
  url.searchParams.set('polygons', 'true');
  url.searchParams.set('denoise', '1');
  url.searchParams.set('generalize', '10');
  url.searchParams.set('access_token', mapboxgl.accessToken);
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error(`Isochrone ${res.status}: ${await res.text().catch(()=>res.statusText)}`);
  return await res.json();
}

// Build a corridor: sample along the route, get isochrones, union polygons
async function buildRouteCorridor(line, minutes, profile){
  if (!line || !line.coordinates || line.coordinates.length < 2) {
    throw new Error('No route geometry yet. Set start/end and ensure a route is visible.');
  }

  const lineKm = turf.length(line, { units:'kilometers' });
  if (lineKm === 0) throw new Error('Route length is zero.');

  // derive sampling spacing from minutes and a rough average speed
  const r_km = (AVG_SPEED_KMH[profile] || 65) * (minutes/60); // radius-ish
  let spacing = Math.max(0.75 * r_km, 1);                    // km between samples
  let count = Math.ceil(lineKm / spacing);
  if (count > MAX_SAMPLES) {
    count = MAX_SAMPLES;
    spacing = lineKm / count;
  }

  // sample points along the line
  const samples = [];
  for (let i = 0; i <= count; i++) {
    const d = Math.min(i * spacing, lineKm);
    const pt = turf.along(line, d, { units:'kilometers' });
    samples.push(pt.geometry.coordinates);
  }

  // fetch isochrones sequentially (kinder on rate limits)
  let unionGeom = null;
  for (let i = 0; i < samples.length; i++) {
    const [lng, lat] = samples[i];
    const gj = await fetchIso(lng, lat, minutes, profile);
    const feat = gj.features?.[0];
    if (!feat) continue;
    unionGeom = unionGeom
      ? turf.union({ type:'Feature', geometry: unionGeom }, feat).geometry
      : feat.geometry;
  }

  if (!unionGeom) throw new Error('Failed to build isochrone corridor (no polygons returned).');
  return unionGeom; // MultiPolygon/Polygon
}

// Apply filter to points
function applyIsoFilter(geom){
  const cond = ['all'];
  if (geom) cond.push(['within', geom]);
  if (map.getLayer(DATA_LAYER_ID)) map.setFilter(DATA_LAYER_ID, cond);
}

// ====== BUTTONS ======
applyBtn.addEventListener('click', async () => {
  clearErr();
  try {
    if (!currentRouteLine) throw new Error('No route yet. Set a start and destination in the Directions box.');
    const minutes = Number(minsInput.value || 15);
    const mode = document.querySelector('input[name="mode"]:checked').value || 'driving';

    const corridor = await buildRouteCorridor(currentRouteLine, minutes, mode);

    // update display + filter
    map.getSource(ISO_SOURCE_ID).setData({ type:'FeatureCollection', features:[{ type:'Feature', geometry:corridor, properties:{} }] });
    applyIsoFilter(corridor);

    // zoom to corridor
    const bbox = turf.bbox({ type:'Feature', geometry:corridor, properties:{} });
    if (bbox && isFinite(bbox[0])) map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { padding: 50, duration: 700 });

  } catch (e) {
    showErr(e.message || String(e));
    console.error(e);
  }
});

clearBtn.addEventListener('click', () => {
  clearErr();
  map.getSource(ISO_SOURCE_ID).setData({ type:'FeatureCollection', features: [] });
  applyIsoFilter(null);
});
</script>
</body>
</html>
