<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Didius Travel Map — Single/Route with Custom Icons</title>

<link href="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css" rel="stylesheet" />
<link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.css" rel="stylesheet" />

<style>
  html,body{height:100%;margin:0;font-family:system-ui,Inter,Arial}
  #map{height:100vh;width:100%}

  .panel{
    position:absolute;z-index:6;left:12px;top:12px;
    background:#fff;padding:10px 12px;border-radius:12px;border:1px solid #e5e7eb;
    box-shadow:0 6px 20px rgba(0,0,0,.12);
    display:flex;gap:8px;align-items:center;flex-wrap:wrap;max-width:560px
  }
  .panel label{font-size:12px;color:#111827}
  .panel input[type="range"]{width:180px}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:4px 10px;font-size:12px;background:#f8fafc;cursor:pointer}
  .sep{width:1px;height:26px;background:#e5e7eb;display:inline-block;margin:0 2px}

  .search-wrap{width:100%;display:flex;flex-direction:column;gap:8px;margin-top:6px}
  .search-row{width:100%}
  .search-row .mapboxgl-ctrl-directions{ width:100%; max-width:100% }
  .search-row .directions-control{ box-shadow:none }

  /* Single mode look: identical box but hide Destination + summary/instructions */
  .single-like .mapbox-directions-destination{ display:none !important; }
  .single-like .mapbox-directions-instructions,
  .single-like .mapbox-directions-route-summary{ display:none !important; }

  .mapboxgl-ctrl-bottom-right{ margin:12px }

  #legend{
    position:absolute;left:12px;bottom:12px;background:#fff;
    border:1px solid #e5e7eb;border-radius:12px;padding:8px 10px;
    box-shadow:0 6px 20px rgba(0,0,0,.12);z-index:2
  }
  #err{
    position:absolute;left:12px;top:calc(12px + 120px);
    background:#fff;border:1px solid #e5e7eb;border-radius:10px;
    padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.12);
    font-size:12px;max-width:70ch;display:none;z-index:8;white-space:pre-wrap
  }
  #dbg{
    position:absolute;right:12px;bottom:12px;background:#fff;
    border:1px solid #e5e7eb;border-radius:10px;padding:6px 8px;font-size:12px;z-index:4
  }
  button:disabled{opacity:.5;cursor:not-allowed}

  /* Pretty popups */
  .mapboxgl-popup.poi .mapboxgl-popup-content{
    font-family: system-ui, Inter, Arial;
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid #e5e7eb;
    box-shadow: 0 10px 30px rgba(0,0,0,.18);
  }
  .poi .h{
    font-weight:700;font-size:14px;line-height:1.1;margin:0 0 4px 0;color:#111827
  }
  .poi .sub{
    font-size:12px;color:#4b5563;margin-bottom:6px
  }
  .poi .row{ display:flex; gap:8px; align-items:center; margin:6px 0 }
  .poi .badge{
    display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; font-weight:600; color:#fff
  }
  .poi .b-green{ background:#10b981 }   /* Best */
  .poi .b-teal{  background:#14b8a6 }   /* 1.5 */
  .poi .b-blue{  background:#3b82f6 }   /* Good */
  .poi .b-amber{ background:#f59e0b }   /* Meh */
  .poi .b-red{   background:#ef4444 }   /* Worst */
  .poi .btns{ display:flex; gap:8px; margin-top:10px }
  .poi button{
    border:1px solid #e5e7eb; background:#f8fafc; border-radius:8px; padding:6px 10px;
    font-size:12px; cursor:pointer
  }
  .poi a{ color:#2563eb; text-decoration:none }
  .poi a:hover{ text-decoration:underline }

  /* Help box */
  #helpBox{
    position:absolute;right:12px;bottom:110px; /* above legend */
    background:#ffffff;border:1px solid #e5e7eb;border-radius:12px;
    box-shadow:0 8px 24px rgba(0,0,0,.14);
    width:min(92vw,520px);max-height:55vh;overflow:auto;z-index:3;
    display:none;padding:14px 16px
  }
  #helpBox h3{margin:10px 0 6px 0;font-size:14px}
  #helpBox p{margin:6px 0;font-size:13px;line-height:1.4}
  #helpBox .row{margin:6px 0;font-size:13px;line-height:1.35}
  #helpBox .close{
    position:sticky;top:0;display:flex;justify-content:flex-end;margin:-6px -6px 6px 0;
    background:linear-gradient(#fff, #fff)
  }
  #helpBox .close button{
    border:1px solid #e5e7eb;background:#f8fafc;border-radius:8px;padding:4px 8px;font-size:12px;cursor:pointer
  }
  #helpBox hr{border:0;border-top:1px solid #e5e7eb;margin:10px 0}
</style>
</head>
<body>

<div class="panel">
  <span class="pill">
    Mode:
    <label style="margin-left:6px"><input type="radio" name="uxmode" value="point" checked> Single point</label>
    <label><input type="radio" name="uxmode" value="route"> Route</label>
  </span>

  <span class="sep"></span>

  <span class="pill" style="background:#fff">
    Within <input id="mins" type="range" min="5" max="120" step="5" value="15" />
    <strong><span id="minsVal">15</span> min</strong>
  </span>

  <span class="pill" style="background:#fff">
    Travel:
    <label><input type="radio" name="mode" value="driving" checked> Driving</label>
    <label><input type="radio" name="mode" value="walking"> Walking</label>
    <label><input type="radio" name="mode" value="cycling"> Cycling</label>
  </span>

  <button id="applyBtn" class="pill" disabled>Apply</button>
  <button id="clearIso" class="pill" disabled>Clear</button>

  <label class="pill" style="background:#fff">
    <input id="fitToggle" type="checkbox" />
    Fit view to area
  </label>

  <!-- Help pill -->
  <button id="helpBtn" class="pill" title="How this map works">Help</button>

  <div class="search-wrap">
    <div id="dirMount" class="search-row single-like"></div>
  </div>
</div>

<div id="map" aria-label="Interactive map"></div>

<!-- Hideable help box -->
<div id="helpBox" aria-live="polite">
  <div class="close"><button id="helpClose">Hide</button></div>
  <h3>How to use this map</h3>
  <p><b>Single point</b>: choose a Location in the box, pick minutes and travel mode, then press Apply to see everything within that time.</p>
  <p><b>Route</b>: switch to Route, enter A and B, choose minutes and mode, then Apply to find stops along the entire route.</p>
  <hr>
  <h3>Activity/Accomodation Rating Explanation</h3>
  <div class="row"><b>1) Top Tier</b> — Really cool. If you considered doing something similar, this will be an excellent choice.</div>
  <div class="row"><b>2) Worth It</b> — You will not be disappointed. It will be a good experience that feels worth the price/time.</div>
  <div class="row"><b>3) Meh</b> — The title says it… Just Meh. There are probably other things that I would have rather spend me time on.</div>
  <div class="row"><b>4) Not Worth It</b> — Again, the title say it all. Unless you are REALLY looking forward to this thing, I would avoid it. There are much better things to spend time and money on.</div>
  <hr>
  <h3>Restaurant Rating Explanation</h3>
  <div class="row"><b>1) Must Stop</b> — Fantastic. If you are within a distance that feels reasonable to you, you should go here. These are the places that you would be PUMPED to tell someone about.</div>
  <div class="row"><b>1.5) Must Stop But…</b> — This is an odd one. Fantastic place, but requires you to really be in a particular mood.</div>
  <div class="row"><b>2) Go Back</b> — These are just good restaurants. You leave very happy with the meal. But they aren’t the ones that necessarily give you anything out of the ordinary, but they are very good.</div>
  <div class="row"><b>3) Good 2nd Choice</b> — This is an odd one. Not a bad restaurant, but probably not something you would choose to go back to. This is one of those that, if your main choice is booked and you cant get in, you can choose this and know that it wont be excellent, but it will be a decent meal.</div>
  <div class="row"><b>4) Don’t Go Back</b> — Again, the title say it all. Unless you are REALLY looking forward to this thing, I would avoid it. There are much better things to spend time and money on.</div>
</div>

<div id="legend"></div>
<div id="err"></div>
<div id="dbg">Visible points: <span id="visCount">0</span></div>

<script src="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
(async function(){
  // ===== CONFIG =====
  mapboxgl.accessToken = 'pk.eyJ1IjoiYnJhZDEzbWFydGluIiwiYSI6ImNta2p6eHI5MzE4YzAzY282aXE4Mjhxc3QifQ.tkosuQGdRkfSMoRVWCakbg';
  const STYLE_URL = 'mapbox://styles/brad13martin/cmkjztnvs001u01qm6lsmeold';
  const GEO_PATH  = 'https://brad13martin.github.io/travel-map/data/places.geojson';

  const GEO_SOURCE_ID='places-geo', GEO_LAYER_CIRCLES='places-geo-circles', GEO_LAYER_ICONS='places-geo-icons';
  const ISO_SOURCE_ID='iso-source', ISO_LAYER_FILL='iso-fill', ISO_LAYER_LINE='iso-line';
  const AVG_SPEED_KMH={driving:65,walking:5,cycling:18};
  const MAX_SAMPLES_HARD=60;

  // ===== UI refs =====
  const minsInput=document.getElementById('mins');
  const minsVal=document.getElementById('minsVal');
  const applyBtn=document.getElementById('applyBtn');
  const clearBtn=document.getElementById('clearIso');
  const fitToggle=document.getElementById('fitToggle');
  const errBox=document.getElementById('err');
  const visOut=document.getElementById('visCount');
  const dirMount=document.getElementById('dirMount');

  // Help elements
  const helpBtn=document.getElementById('helpBtn');
  const helpBox=document.getElementById('helpBox');
  const helpClose=document.getElementById('helpClose');

  function showErr(msg){ errBox.style.display='block'; errBox.textContent=msg; }
  function clearErr(){ errBox.style.display='none'; errBox.textContent=''; }
  minsInput.addEventListener('input', ()=> minsVal.textContent=minsInput.value);

  // Help box toggle with persistence
  function setHelp(open){
    helpBox.style.display = open ? 'block' : 'none';
    localStorage.setItem('helpOpen', open ? '1':'0');
  }
  helpBtn.addEventListener('click', ()=> setHelp(helpBox.style.display!=='block'));
  helpClose.addEventListener('click', ()=> setHelp(false));
  // open by default on first visit
  setHelp(localStorage.getItem('helpOpen') !== '0');

  // ===== MAP =====
  const map=new mapboxgl.Map({ container:'map', style:STYLE_URL, center:[-80,40], zoom:5 });
  map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
  map.on('error', ev => {
    const err = ev && ev.error;
    const msg = (err && (err.message || err.toString())) || '';
    const status = err && (err.status || err.code);
    const isHttpFail = typeof status === 'number' && status >= 400;
    const looksFatal = /network|fetch|geocode|isochrone|setData|source.*missing|layer.*not found/i.test(msg);
    if (isHttpFail || looksFatal) showErr('Mapbox: ' + msg);
    else console.warn('Mapbox warning (suppressed):', ev);
  });

  let hasFitOnce=false, mapReady=false;
  let currentRouteLine=null, currentIsoFeature=null;

  // ===== Directions control (one box; we hide Destination in single mode) =====
  const dir = new MapboxDirections({
    accessToken: mapboxgl.accessToken, profile:'mapbox/driving', unit:'imperial',
    alternatives:true, controls:{ instructions:true, inputs:true, profileSwitcher:true },
    interactive:false, draggable:false, geometries:'geojson'
  });
  const dirEl = dir.onAdd(map);
  dirMount.appendChild(dirEl);

  // Relabel “A” to “Location” in single mode
  function patchSingleLabels(){
    const originInput = dirMount.querySelector('.mapbox-directions-origin input[type="text"]');
    if (originInput) originInput.placeholder = 'Location';
    const badges = dirMount.querySelectorAll('span,div');
    for (const el of badges){
      const t=(el.textContent||'').trim();
      if (t==='A' && /directions|mapbox/i.test(el.className||'')){
        el.textContent='Location';
        el.style.fontSize='12px';
        el.style.fontWeight='600';
        break;
      }
    }
  }

  function currentUXMode(){ return (document.querySelector('input[name="uxmode"]:checked')?.value) || 'point'; }
  function applySingleLook(enable){
    dirMount.classList.toggle('single-like', enable);
    if (enable){
      try{ dir.setDestination(''); }catch{}
      patchSingleLabels();
    }
  }
  // Initial mode look and label patch
  applySingleLook(true);
  setTimeout(patchSingleLabels, 150);

  // Mode change
  document.querySelectorAll('input[name="uxmode"]').forEach(r=> r.addEventListener('change', ()=>{
    const single = currentUXMode()==='point';
    applySingleLook(single);
    maybeEnableApply();
  }));

  // Enable/disable Apply
  function maybeEnableApply(){
    if(!mapReady){ applyBtn.disabled=true; clearBtn.disabled=true; return; }
    if (currentUXMode()==='point'){
      const originInput = dirMount.querySelector('.mapbox-directions-origin input[type="text"]');
      applyBtn.disabled = !(originInput && originInput.value.trim().length>0);
      clearBtn.disabled = false;
    }else{
      const hasO = !!dir.getOrigin();
      const hasD = !!dir.getDestination();
      applyBtn.disabled = !(hasO && hasD);
      clearBtn.disabled = false;
    }
  }
  document.addEventListener('input', (e)=>{
    if (e.target && e.target.closest('.mapbox-directions-origin')) maybeEnableApply();
    if (e.target && e.target.closest('.mapbox-directions-destination')) maybeEnableApply();
  });
  dir.on('origin', maybeEnableApply);
  dir.on('destination', maybeEnableApply);

  // Route geometry
  dir.on('route', e=>{
    try{
      const r=e?.route?.[0];
      if(r?.geometry?.type==='LineString') currentRouteLine=r.geometry;
      else if(r?.geometry?.coordinates) currentRouteLine={ type:'LineString', coordinates:r.geometry.coordinates };
      else currentRouteLine=null;
    }catch{ currentRouteLine=null; }
    maybeEnableApply();
  });

  // ===== Ensure ISO layers exist (for setData safety) =====
  function ensureIsoLayers(){
    if (!map.getSource(ISO_SOURCE_ID)){
      map.addSource(ISO_SOURCE_ID,{ type:'geojson', data:{ type:'FeatureCollection', features:[] } });
    }
    if (!map.getLayer(ISO_LAYER_FILL)){
      map.addLayer({ id:ISO_LAYER_FILL, type:'fill', source:ISO_SOURCE_ID, paint:{ 'fill-color':'#7c3aed','fill-opacity':0.18 } });
    }
    if (!map.getLayer(ISO_LAYER_LINE)){
      map.addLayer({ id:ISO_LAYER_LINE, type:'line', source:ISO_SOURCE_ID, paint:{ 'line-color':'#5b21b6','line-width':2.5,'line-opacity':0.9 } });
    }
  }

  // ===== Visible count helper (set later once layers exist) =====
  function updateVisibleCount(){
    try {
      const layer = map.getLayer(GEO_LAYER_ICONS) ? GEO_LAYER_ICONS : GEO_LAYER_CIRCLES;
      visOut.textContent = layer ? String(map.queryRenderedFeatures({ layers:[layer] }).length) : '0';
    } catch { visOut.textContent = 'n/a'; }
  }

  // ===== Load data and icons =====
  map.on('load', async ()=>{
    try{
      ensureIsoLayers();

      // — Load places
      const resp=await fetch(GEO_PATH,{ cache:'no-store' });
      if(!resp.ok) throw new Error(`Fetch failed: ${resp.status} ${resp.statusText}`);
      const raw=await resp.json();

      let feats=[], interpretAsRows=false;
      if (raw?.type==='FeatureCollection' && Array.isArray(raw.features)) feats=raw.features;
      else if (Array.isArray(raw)) { interpretAsRows = !(raw[0]?.geometry || raw[0]?.type); feats=raw; }
      else throw new Error('Unrecognized data format.');

      const norm=[];
      const pushPoint=(lon,lat,props)=>{
        let x=Number(lon), y=Number(lat);
        if(!Number.isFinite(x)||!Number.isFinite(y)) return false;
        if(Math.abs(x)<=90 && Math.abs(y)>90) [x,y]=[y,x];
        if(x<-180||x>180||y<-90||y>90) return false;
        norm.push({ type:'Feature', geometry:{ type:'Point', coordinates:[x,y] }, properties:props||{} });
        return true;
      };

      if(!interpretAsRows){
        for(const f of feats){
          const p=f.properties||{};
          if(f.geometry?.type==='Point' && Array.isArray(f.geometry.coordinates)){
            if(pushPoint(f.geometry.coordinates[0], f.geometry.coordinates[1], p)) continue;
          }
          const lat=p.Lat??p.lat??p.latitude??p.Latitude;
          const lon=p.Long??p.long??p.lng??p.Lng??p.longitude??p.Longitude;
          if(lat!=null && lon!=null) pushPoint(lon,lat,p);
        }
      }else{
        const guess=(o,keys)=>{ for(const k of keys) if(o[k]!=null && o[k]!=='') return o[k]; return null; };
        for(const row of feats){
          const lat=guess(row,['Lat','lat','Latitude','latitude']);
          const lon=guess(row,['Long','long','Lng','lng','Longitude','longitude','Lon','lon']);
          const props={...row};
          if(lat!=null && lon!=null){ if(pushPoint(lon,lat,props)) continue; }
          const coord=row.coordinates??row.Coordinates??row.coord??row.Coord;
          if(typeof coord==='string' && coord.includes(',')){
            const [a,b]=coord.split(',').map(s=>s.trim());
            if(pushPoint(a,b,props)) continue;
            if(pushPoint(b,a,props)) continue;
          }
        }
      }

      if(!norm.length) throw new Error('No valid point features found in places.geojson.');
      const gj={ type:'FeatureCollection', features:norm };

      if (map.getLayer(GEO_LAYER_CIRCLES)) map.removeLayer(GEO_LAYER_CIRCLES);
      if (map.getLayer(GEO_LAYER_ICONS))   map.removeLayer(GEO_LAYER_ICONS);
      if (map.getSource(GEO_SOURCE_ID))    map.removeSource(GEO_SOURCE_ID);

      map.addSource(GEO_SOURCE_ID,{ type:'geojson', data:gj });

      // Base circles (thin) under icons
      map.addLayer({
        id:GEO_LAYER_CIRCLES, type:'circle', source:GEO_SOURCE_ID,
        paint:{ 'circle-radius':4,'circle-color':'#2563eb','circle-stroke-color':'#fff','circle-stroke-width':1,'circle-opacity':0.6 }
      });

      // — Load custom PNG icons
      async function addIcon(name) {
        const url = `./assets/icons/${name}.png`; // relative to docs/index.html
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Icon fetch failed: ${url}`);
        const bmp = await createImageBitmap(await res.blob());
        if (!map.hasImage(name)) map.addImage(name, bmp, { pixelRatio: 2 }); // use 1 if not @2x
      }
      const iconNames = [
        'Activity-Green','Activity-Blue','Activity-Orange','Activity-Red',
        'Food-Green','Food-Teal','Food-Blue','Food-Orange','Food-Red',
        'Hike-Green','Hike-Blue','Hike-Orange','Hike-Red',
        'Stay-Green','Stay-Blue','Stay-Orange','Stay-Red'
      ];
      for (const n of iconNames) { await addIcon(n); }

      // — Icon logic by Type and Rating
      const typeLower = ['downcase', ['coalesce', ['get','Type'], '' ]];
      const isRestaurant = ['match', typeLower, ['restaurant','restaurants','food','eat'], true, false];
      const isActivity   = ['match', typeLower, ['activity','activities','attraction'], true, false];
      const isHike       = ['match', typeLower, ['hike','hiking','trail','walk'], true, false];
      const isStay       = ['match', typeLower, ['accommodation','accomodation','lodging','hotel','stay'], true, false];

      const restRatingText  = ['coalesce', ['get','Restaurant Rating'], '' ];
      const otherRatingText = ['coalesce', ['get','Activity / Accommodations Rating'], '' ];

      const restIconByRating = [
        'match', restRatingText,
        '1) Must Stop',        'Food-Green',
        '1.5) Must Stop BUT…', 'Food-Teal',
        '2) Go Back',          'Food-Blue',
        '3) Good 2nd Choice',  'Food-Orange',
        '4) Don’t Go Back',    'Food-Red',
        /* default */          'Food-Blue'
      ];
      const activityIconByRating = [
        'match', otherRatingText,
        '1) Top Tier',     'Activity-Green',
        '2) Worth It',     'Activity-Blue',
        '3) Meh',          'Activity-Orange',
        '4) Not Worth It', 'Activity-Red',
        /* default */      'Activity-Blue'
      ];
      const hikeIconByRating = [
        'match', otherRatingText,
        '1) Top Tier',     'Hike-Green',
        '2) Worth It',     'Hike-Blue',
        '3) Meh',          'Hike-Orange',
        '4) Not Worth It', 'Hike-Red',
        /* default */      'Hike-Blue'
      ];
      const stayIconByRating = [
        'match', otherRatingText,
        '1) Top Tier',     'Stay-Green',
        '2) Worth It',     'Stay-Blue',
        '3) Meh',          'Stay-Orange',
        '4) Not Worth It', 'Stay-Red',
        /* default */      'Stay-Blue'
      ];

      const iconImageExpr = [
        'case',
        isRestaurant, restIconByRating,
        isActivity,   activityIconByRating,
        isHike,       hikeIconByRating,
        isStay,       stayIconByRating,
        /* fallback */ 'Activity-Blue'
      ];

      map.addLayer({
        id: GEO_LAYER_ICONS,
        type: 'symbol',
        source: GEO_SOURCE_ID,
        layout: {
          'icon-image': iconImageExpr,
          'icon-size': 1,
          'icon-allow-overlap': true
        },
        paint: { 'icon-opacity': 1 }
      });
      try { map.moveLayer(GEO_LAYER_ICONS); } catch {}

      // Fit to data
      try{
        const b=turf.bbox(gj);
        if(b&&isFinite(b[0])&&b[0]!==b[2]&&b[1]!==b[3]){
          map.fitBounds([[b[0],b[1]],[b[2],b[3]]],{ padding:60, duration:600 });
        }
      }catch{}

      // Popups on icon layer (pretty, with rating badge + actions)
      map.on('click', GEO_LAYER_ICONS, e=>{
        const f   = e.features[0];
        const p   = f.properties || {};
        const ll  = f.geometry.coordinates;
        const get = k => (p[k] ? String(p[k]) : '');

        const name = get('Name') || get('name') || 'Place';
        const type = get('Type') || '';
        const city = get('City') || '';
        const state= get('State') || '';
        const url  = get('URL')  || get('Link') || '';
        const rRest  = get('Restaurant Rating');
        const rOther = get('Activity / Accommodations Rating');

        const typeLower = type.toLowerCase();
        const isRestaurantLocal = /restaurant|food|eat/.test(typeLower);

        function badge(text, cls){ return `<span class="badge ${cls}">${text}</span>`; }
        function restaurantBadge(txt){
          switch(txt){
            case '1) Must Stop':               return badge('1) Must Stop','b-green');
            case '1.5) Must Stop BUT…':        return badge('1.5 Must Stop (but…)','b-teal');
            case '2) Go Back':                 return badge('2) Go Back','b-blue');
            case '3) Good 2nd Choice':         return badge('3) Good 2nd Choice','b-amber');
            case '4) Don’t Go Back':           return badge('4) Don’t Go Back','b-red');
            default:                           return '';
          }
        }
        function otherBadge(txt){
          switch(txt){
            case '1) Top Tier':                return badge('1) Top Tier','b-green');
            case '2) Worth It':                return badge('2) Worth It','b-blue');
            case '3) Meh':                     return badge('3) Meh','b-amber');
            case '4) Not Worth It':            return badge('4) Not Worth It','b-red');
            default:                           return '';
          }
        }
        const ratingChip = isRestaurantLocal ? restaurantBadge(rRest) : otherBadge(rOther);
        const locLine = (city || state) ? `${city}${city && state ? ', ' : ''}${state}` : '';
        const notes   = get('Notes');

        const html = `
          <div class="poi">
            <div class="h">${name}</div>
            <div class="sub">${type}${locLine ? ' · ' + locLine : ''}</div>
            ${ratingChip ? `<div class="row">${ratingChip}</div>` : ''}
            ${notes ? `<div style="font-size:12px;color:#111827;margin-top:6px">${notes}</div>` : ''}
            <div class="btns">
              <button id="poi-set-origin">Set as Origin</button>
              <button id="poi-set-dest">Set as Destination</button>
              ${url ? `<a href="${url}" target="_blank" rel="noopener" style="align-self:center">Website →</a>` : ''}
            </div>
          </div>
        `;
        const popup = new mapboxgl.Popup({ className:'poi', offset:12, closeButton:true, closeOnClick:true, maxWidth:'300px' })
          .setLngLat(ll).setHTML(html).addTo(map);
        popup.on('open', ()=>{
          const btnO = document.getElementById('poi-set-origin');
          const btnD = document.getElementById('poi-set-dest');
          if (btnO) btnO.onclick = ()=> { try{ dir.setOrigin(ll); }catch{} };
          if (btnD) btnD.onclick = ()=> { try{ dir.setDestination(ll); }catch{} };
        });
      });

      map.on('mouseenter', GEO_LAYER_ICONS, ()=> map.getCanvas().style.cursor='pointer');
      map.on('mouseleave', GEO_LAYER_ICONS, ()=> map.getCanvas().style.cursor='');

      // Legend (icon-based)
      const legend = document.getElementById('legend');
      legend.innerHTML = `
        <div style="font-weight:700;margin-bottom:6px">Legend</div>

        <div style="margin-bottom:8px">
          <div style="font-size:12px;color:#374151;margin-bottom:4px">Types</div>
          <div style="display:grid;grid-template-columns:auto 1fr;gap:6px 10px;align-items:center">
            <img src="./assets/icons/Food-Green.png"    width="16" height="16" alt="Restaurant icon"><div>Restaurant</div>
            <img src="./assets/icons/Activity-Blue.png" width="16" height="16" alt="Activity icon"><div>Activity</div>
            <img src="./assets/icons/Hike-Blue.png"     width="16" height="16" alt="Hike icon"><div>Hike</div>
            <img src="./assets/icons/Stay-Blue.png"     width="16" height="16" alt="Accommodation icon"><div>Accommodation</div>
          </div>
        </div>

        <div style="margin-bottom:8px">
          <div style="font-size:12px;color:#374151;margin-bottom:4px">Restaurant ratings</div>
          <div style="display:grid;grid-template-columns:auto 1fr;gap:6px 10px;align-items:center">
            <img src="./assets/icons/Food-Green.png"  width="16" height="16" alt=""><div><b>1)</b> Must Stop</div>
            <img src="./assets/icons/Food-Teal.png"   width="16" height="16" alt=""><div><b>1.5)</b> Must Stop BUT…</div>
            <img src="./assets/icons/Food-Blue.png"   width="16" height="16" alt=""><div><b>2)</b> Go Back</div>
            <img src="./assets/icons/Food-Orange.png" width="16" height="16" alt=""><div><b>3)</b> Good 2nd Choice</div>
            <img src="./assets/icons/Food-Red.png"    width="16" height="16" alt=""><div><b>4)</b> Don’t Go Back</div>
          </div>
        </div>

        <div style="margin-bottom:6px">
          <div style="font-size:12px;color:#374151;margin-bottom:4px">Activity / Hike / Accommodation ratings</div>
          <div style="display:grid;grid-template-columns:auto 1fr;gap:6px 10px;align-items:center">
            <img src="./assets/icons/Activity-Green.png" width="16" height="16" alt=""><div><b>1)</b> Top Tier</div>
            <img src="./assets/icons/Activity-Blue.png"  width="16" height="16" alt=""><div><b>2)</b> Worth It</div>
            <img src="./assets/icons/Activity-Orange.png" width="16" height="16" alt=""><div><b>3)</b> Meh</div>
            <img src="./assets/icons/Activity-Red.png"    width="16" height="16" alt=""><div><b>4)</b> Not Worth It</div>
          </div>
        </div>

        <div style="font-size:12px;display:flex;align-items:center;gap:8px">
          <span style="display:inline-block;width:12px;height:12px;background:#7c3aed;border-radius:2px"></span>
          Reachable area (within selected minutes)
        </div>
      `;

      mapReady=true;
      maybeEnableApply();
      clearBtn.disabled=false;

      updateVisibleCount();
      map.on('moveend', updateVisibleCount);

    }catch(e){ showErr(e.message||String(e)); console.error(e); }
  });

  // ===== Geocode helper (for Single point) =====
  async function geocodeQuery(q){
    const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json`);
    url.searchParams.set('access_token', mapboxgl.accessToken);
    url.searchParams.set('limit','1');
    const r = await fetch(url.toString());
    if(!r.ok) throw new Error(`Geocode ${r.status}`);
    const j = await r.json();
    const f = j.features?.[0];
    if(!f?.center) throw new Error('No results for that location.');
    return {lng:f.center[0], lat:f.center[1]};
  }

  // ===== Isochrone helpers =====
  async function fetchIso(lng,lat,minutes,profile){
    const url=new URL(`https://api.mapbox.com/isochrone/v1/mapbox/${profile}/${lng},${lat}`);
    url.searchParams.set('contours_minutes',String(minutes));
    url.searchParams.set('polygons','true');
    url.searchParams.set('denoise','1');
    url.searchParams.set('generalize','10');
    url.searchParams.set('access_token',mapboxgl.accessToken);
    const res=await fetch(url.toString());
    if(!res.ok) throw new Error(`Isochrone ${res.status}: ${await res.text().catch(()=>res.statusText)}`);
    return await res.json();
  }

  async function buildRouteCorridor(line,minutes,profile){
    const lineKm=turf.length(line,{units:'kilometers'});
    if(!isFinite(lineKm)||lineKm<=0) throw new Error('Route length is zero.');
    const r_km=(AVG_SPEED_KMH[profile]||65)*(minutes/60);
    let spacingKm=Math.max(0.5*r_km,1);
    let count=Math.ceil(lineKm/spacingKm);
    if(count>MAX_SAMPLES_HARD){ count=MAX_SAMPLES_HARD; spacingKm=lineKm/count; }
    const samples=[];
    for(let i=0;i<=count;i++){
      const d=Math.min(i*spacingKm,lineKm);
      const pt=turf.along(line,d,{units:'kilometers'});
      samples.push(pt.geometry.coordinates);
    }
    samples[samples.length-1]=line.coordinates[line.coordinates.length-1];
    let unionGeom=null;
    for(let i=0;i<samples.length;i++){
      const [lng,lat]=samples[i];
      const gj=await fetchIso(lng,lat,minutes,profile);
      const feat=gj.features?.[0];
      if(!feat) continue;
      unionGeom = unionGeom
        ? turf.union({type:'Feature',geometry:unionGeom,properties:{}}, feat)?.geometry || unionGeom
        : feat.geometry;
    }
    if(!unionGeom) throw new Error('Failed to build isochrone corridor.');
    return unionGeom;
  }

  // ===== Filter helpers =====
  function applyIsoFilter(featureOrNull){
    const filt = featureOrNull ? ['within',['literal',featureOrNull]] : null;
    if (map.getLayer(GEO_LAYER_CIRCLES)) map.setFilter(GEO_LAYER_CIRCLES, filt);
    if (map.getLayer(GEO_LAYER_ICONS))   map.setFilter(GEO_LAYER_ICONS,   filt);
    if (map.getLayer(GEO_LAYER_CIRCLES)) map.setPaintProperty(GEO_LAYER_CIRCLES,'circle-opacity', featureOrNull ? 0.2 : 0.6);
    if (map.getLayer(GEO_LAYER_ICONS))   map.setPaintProperty(GEO_LAYER_ICONS,'icon-opacity', 1);
    updateVisibleCount();
  }

  // ===== Apply / Clear =====
  applyBtn.addEventListener('click', async ()=>{
    clearErr();
    if (!mapReady){ showErr('Map is still loading.'); return; }
    ensureIsoLayers();

    const minutes=Number(minsInput.value||15);
    const profile=(document.querySelector('input[name="mode"]:checked')?.value||'driving');

    try{
      if(currentUXMode()==='point'){
        const originInput = dirMount.querySelector('.mapbox-directions-origin input[type="text"]');
        if(!originInput || !originInput.value.trim()) throw new Error('Enter a Location.');
        const o = await geocodeQuery(originInput.value.trim());
        const gj=await fetchIso(o.lng,o.lat,minutes,profile);
        const feat=gj.features?.[0]; if(!feat) throw new Error('No isochrone returned.');
        currentIsoFeature=feat;
      }else{
        let line = currentRouteLine;
        if(!line){
          try{
            const src=map.getSource('directions');
            const data=src && (src._data || (src.serialize && src.serialize().data));
            if(data?.features?.length){
              const all=[];
              for(const f of data.features){
                if(!f.geometry) continue;
                if(f.geometry.type==='LineString' && f.geometry.coordinates?.length>1) all.push(...f.geometry.coordinates);
                else if(f.geometry.type==='MultiLineString' && Array.isArray(f.geometry.coordinates)){
                  for(const seg of f.geometry.coordinates) if(Array.isArray(seg)&&seg.length>1) all.push(...seg);
                }
              }
              if(all.length>1) line = { type:'LineString', coordinates:all };
            }
          }catch{}
        }
        if(!line) throw new Error('Enter start and destination and wait for the route to draw.');
        const corridorGeom=await buildRouteCorridor(line,minutes,profile);
        currentIsoFeature={ type:'Feature', geometry:corridorGeom, properties:{} };
      }

      const isoSrc = map.getSource(ISO_SOURCE_ID);
      if(!isoSrc) throw new Error('Isochrone source missing.');
      isoSrc.setData({ type:'FeatureCollection', features:[currentIsoFeature] });

      applyIsoFilter(currentIsoFeature);
      clearErr();
      const bbox=turf.bbox(currentIsoFeature);
      if((fitToggle.checked || !hasFitOnce) && bbox && isFinite(bbox[0])){
        map.fitBounds([[bbox[0],bbox[1]],[bbox[2],bbox[3]]],{ padding:50, duration:600 });
        hasFitOnce=true;
      }
    }catch(e){ showErr(e.message||String(e)); console.error(e); }
  });

  clearBtn.addEventListener('click', ()=>{
    clearErr(); currentIsoFeature=null; hasFitOnce=false;
    ensureIsoLayers();
    const isoSrc = map.getSource(ISO_SOURCE_ID);
    if (isoSrc) isoSrc.setData({ type:'FeatureCollection', features:[] });
    applyIsoFilter(null);
    try{ dir.setOrigin(''); dir.setDestination(''); }catch{}
    const originInput = dirMount.querySelector('.mapbox-directions-origin input[type="text"]');
    if (originInput) originInput.value='';
    maybeEnableApply();
  });

})();
</script>
</body>
</html>
