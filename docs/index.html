<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Didius Travel Map — Stable Sources</title>

<link href="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css" rel="stylesheet" />
<link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.css" rel="stylesheet" />

<style>
  html,body{height:100%;margin:0;font-family:system-ui,Inter,Arial}
  #map{height:100vh;width:100%}

  .panel{
    position:absolute;z-index:6;left:12px;top:12px;
    background:#fff;padding:10px 12px;border-radius:12px;border:1px solid #e5e7eb;
    box-shadow:0 6px 20px rgba(0,0,0,.12);
    display:flex;gap:8px;align-items:center;flex-wrap:wrap;max-width:560px
  }
  .panel label{font-size:12px;color:#111827}
  .panel input[type="range"]{width:180px}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:4px 10px;font-size:12px;background:#f8fafc;cursor:pointer}
  .sep{width:1px;height:26px;background:#e5e7eb;display:inline-block;margin:0 2px}
  .search-wrap{width:100%;display:flex;flex-direction:column;gap:8px;margin-top:6px}
  .search-row{width:100%}
  .search-row.hidden{display:none}
  .search-row .mapboxgl-ctrl-directions{ width:100%; max-width:100% }
  .search-row .directions-control{ box-shadow:none }

  /* Single mode: make it look identical but hide Destination row */
  .single-like .mapbox-directions-destination{ display:none !important; }
  .single-like .mapbox-directions-instructions,
  .single-like .mapbox-directions-route-summary{ display:none !important; }

  .mapboxgl-ctrl-bottom-right{ margin:12px }

  #legend{
    position:absolute;left:12px;bottom:12px;background:#fff;
    border:1px solid #e5e7eb;border-radius:12px;padding:8px 10px;
    box-shadow:0 6px 20px rgba(0,0,0,.12);z-index:2
  }
  #err{
    position:absolute;left:12px;top:calc(12px + 120px);
    background:#fff;border:1px solid #e5e7eb;border-radius:10px;
    padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.12);
    font-size:12px;max-width:70ch;display:none;z-index:8;white-space:pre-wrap
  }
  #dbg{
    position:absolute;right:12px;bottom:12px;background:#fff;
    border:1px solid #e5e7eb;border-radius:10px;padding:6px 8px;font-size:12px;z-index:4
  }
  button:disabled{opacity:.5;cursor:not-allowed}
</style>
</head>
<body>

<div class="panel">
  <span class="pill">
    Mode:
    <label style="margin-left:6px"><input type="radio" name="uxmode" value="point" checked> Single point</label>
    <label><input type="radio" name="uxmode" value="route"> Route</label>
  </span>

  <span class="sep"></span>

  <span class="pill" style="background:#fff">
    Within <input id="mins" type="range" min="5" max="120" step="5" value="15" />
    <strong><span id="minsVal">15</span> min</strong>
  </span>

  <span class="pill" style="background:#fff">
    Travel:
    <label><input type="radio" name="mode" value="driving" checked> Driving</label>
    <label><input type="radio" name="mode" value="walking"> Walking</label>
    <label><input type="radio" name="mode" value="cycling"> Cycling</label>
  </span>

  <button id="applyBtn" class="pill" disabled>Apply</button>
  <button id="clearIso" class="pill" disabled>Clear</button>

  <label class="pill" style="background:#fff">
    <input id="fitToggle" type="checkbox" />
    Fit view to area
  </label>

  <div class="search-wrap">
    <div id="singleMount" class="search-row single-like"></div>
    <div id="routeMount"  class="search-row hidden"></div>
  </div>
</div>

<div id="map" aria-label="Interactive map"></div>
<div id="legend"></div>
<div id="err"></div>
<div id="dbg">Visible points: <span id="visCount">0</span></div>

<script src="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
(async function(){
  // ===== CONFIG =====
  mapboxgl.accessToken = 'pk.eyJ1IjoiYnJhZDEzbWFydGluIiwiYSI6ImNta2p6eHI5MzE4YzAzY282aXE4Mjhxc3QifQ.tkosuQGdRkfSMoRVWCakbg';
  const STYLE_URL = 'mapbox://styles/brad13martin/cmkjztnvs001u01qm6lsmeold';
  const GEO_PATH  = 'https://brad13martin.github.io/travel-map/data/places.geojson';

  const GEO_SOURCE_ID='places-geo', GEO_LAYER_ID='places-geo-points';
  const ISO_SOURCE_ID='iso-source', ISO_LAYER_FILL='iso-fill', ISO_LAYER_LINE='iso-line';
  const AVG_SPEED_KMH={driving:65,walking:5,cycling:18};
  const MAX_SAMPLES_HARD=60;

  // ===== UI refs =====
  const minsInput=document.getElementById('mins');
  const minsVal=document.getElementById('minsVal');
  const applyBtn=document.getElementById('applyBtn');
  const clearBtn=document.getElementById('clearIso');
  const fitToggle=document.getElementById('fitToggle');
  const errBox=document.getElementById('err');
  const visOut=document.getElementById('visCount');
  const singleMount=document.getElementById('singleMount');
  const routeMount=document.getElementById('routeMount');

  function showErr(msg){ errBox.style.display='block'; errBox.textContent=msg; }
  function clearErr(){ errBox.style.display='none'; errBox.textContent=''; }
  minsInput.addEventListener('input', ()=> minsVal.textContent=minsInput.value);

  // Small helper: wait for condition
  function waitFor(cond, timeout=8000){
    const t0=Date.now();
    return new Promise((res,rej)=>{(function tick(){ if(cond()) return res(); if(Date.now()-t0>timeout) return rej(new Error('Timeout')); requestAnimationFrame(tick); })();});
  }

  // ===== MAP =====
  const map=new mapboxgl.Map({ container:'map', style:STYLE_URL, center:[-80,40], zoom:5 });
  map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
  map.on('error', ev=> showErr('Mapbox: ' + (ev?.error?.message || JSON.stringify(ev))));

  let hasFitOnce=false;
  let mapReady=false;

  // ===== STATE =====
  let currentRouteLine = null;
  let currentIsoFeature = null;

  // ===== Directions controls (identical look) =====
  const singleDir = new MapboxDirections({
    accessToken: mapboxgl.accessToken, profile:'mapbox/driving', unit:'imperial',
    alternatives:false, controls:{ instructions:false, inputs:true, profileSwitcher:true },
    interactive:false, draggable:false, geometries:'geojson'
  });
  const singleEl = singleDir.onAdd(map);
  singleMount.appendChild(singleEl);

  const routeDir = new MapboxDirections({
    accessToken: mapboxgl.accessToken, profile:'mapbox/driving', unit:'imperial',
    alternatives:true, controls:{ instructions:true, inputs:true, profileSwitcher:true },
    interactive:false, draggable:false, geometries:'geojson'
  });
  const routeEl = routeDir.onAdd(map);
  routeMount.appendChild(routeEl);

  // Relabel Single box “A” to “Location”
  function patchSingleLabels(){
    const originInput = singleMount.querySelector('.mapbox-directions-origin input[type="text"]');
    if (originInput) originInput.placeholder = 'Location';
    const badges = singleMount.querySelectorAll('span,div');
    for (const el of badges){
      const t=(el.textContent||'').trim();
      if (t==='A' && /directions|mapbox/i.test(el.className||'')){
        el.textContent='Location';
        el.style.fontSize='12px';
        el.style.fontWeight='600';
        break;
      }
    }
  }
  setTimeout(patchSingleLabels, 120);
  singleDir.on('origin', patchSingleLabels);
  singleDir.on('profile', patchSingleLabels);
  singleDir.on('clear', patchSingleLabels);
  singleDir.on('destination', ()=> { try{ singleDir.setDestination(''); }catch{} });

  // Mode switcher
  function currentUXMode(){ return (document.querySelector('input[name="uxmode"]:checked')?.value) || 'point'; }
  function toggleBoxes(){
    const ux=currentUXMode();
    singleMount.classList.toggle('hidden', ux!=='point');
    routeMount.classList.toggle('hidden',  ux!=='route');
    patchSingleLabels();
    maybeEnableApply();
  }
  document.querySelectorAll('input[name="uxmode"]').forEach(r=> r.addEventListener('change', toggleBoxes));
  toggleBoxes();

  // Enable Apply based on inputs + map ready
  function maybeEnableApply(){
    if(!mapReady){ applyBtn.disabled=true; clearBtn.disabled=true; return; }
    const ux=currentUXMode();
    if (ux==='point'){
      const originInput = singleMount.querySelector('.mapbox-directions-origin input[type="text"]');
      applyBtn.disabled = !(originInput && originInput.value.trim().length>0);
      clearBtn.disabled = false;
    }else{
      const hasO = !!routeDir.getOrigin();
      const hasD = !!routeDir.getDestination();
      applyBtn.disabled = !(hasO && hasD);
      clearBtn.disabled = false;
    }
  }
  document.addEventListener('input', (e)=>{
    if (currentUXMode()==='point' && e.target && e.target.closest('.mapbox-directions-origin')){
      maybeEnableApply();
    }
  });
  routeDir.on('origin', maybeEnableApply);
  routeDir.on('destination', maybeEnableApply);

  routeDir.on('route', e=>{
    try{
      const r=e?.route?.[0];
      if(r?.geometry?.type==='LineString') currentRouteLine=r.geometry;
      else if(r?.geometry?.coordinates) currentRouteLine={ type:'LineString', coordinates:r.geometry.coordinates };
      else currentRouteLine=null;
    }catch{ currentRouteLine=null; }
    maybeEnableApply();
  });

  // Ensure ISO source/layers exist
  function ensureIsoLayers(){
    if (!map.getSource(ISO_SOURCE_ID)){
      map.addSource(ISO_SOURCE_ID,{ type:'geojson', data:{ type:'FeatureCollection', features:[] } });
    }
    if (!map.getLayer(ISO_LAYER_FILL)){
      map.addLayer({ id:ISO_LAYER_FILL, type:'fill', source:ISO_SOURCE_ID, paint:{ 'fill-color':'#7c3aed','fill-opacity':0.18 } });
    }
    if (!map.getLayer(ISO_LAYER_LINE)){
      map.addLayer({ id:ISO_LAYER_LINE, type:'line', source:ISO_SOURCE_ID, paint:{ 'line-color':'#5b21b6','line-width':2.5,'line-opacity':0.9 } });
    }
  }

  // ===== DATA & initial setup =====
  map.on('load', async ()=>{
    try{
      // Create iso layers up-front
      ensureIsoLayers();

      // Load places
      const resp=await fetch(GEO_PATH,{ cache:'no-store' });
      if(!resp.ok) throw new Error(`Fetch failed: ${resp.status} ${resp.statusText}`);
      const raw=await resp.json();

      let feats=[], interpretAsRows=false;
      if (raw?.type==='FeatureCollection' && Array.isArray(raw.features)) feats=raw.features;
      else if (Array.isArray(raw)) { interpretAsRows = !(raw[0]?.geometry || raw[0]?.type); feats=raw; }
      else throw new Error('Unrecognized data format.');

      const norm=[];
      const pushPoint=(lon,lat,props)=>{
        let x=Number(lon), y=Number(lat);
        if(!Number.isFinite(x)||!Number.isFinite(y)) return false;
        if(Math.abs(x)<=90 && Math.abs(y)>90) [x,y]=[y,x];
        if(x<-180||x>180||y<-90||y>90) return false;
        norm.push({ type:'Feature', geometry:{ type:'Point', coordinates:[x,y] }, properties:props||{} });
        return true;
      };

      if(!interpretAsRows){
        for(const f of feats){
          const p=f.properties||{};
          if(f.geometry?.type==='Point' && Array.isArray(f.geometry.coordinates)){
            if(pushPoint(f.geometry.coordinates[0], f.geometry.coordinates[1], p)) continue;
          }
          const lat=p.Lat??p.lat??p.latitude??p.Latitude;
          const lon=p.Long??p.long??p.lng??p.Lng??p.longitude??p.Longitude;
          if(lat!=null && lon!=null) pushPoint(lon,lat,p);
        }
      }else{
        const guess=(o,keys)=>{ for(const k of keys) if(o[k]!=null && o[k]!=='') return o[k]; return null; };
        for(const row of feats){
          const lat=guess(row,['Lat','lat','Latitude','latitude']);
          const lon=guess(row,['Long','long','Lng','lng','Longitude','longitude','Lon','lon']);
          const props={...row};
          if(lat!=null && lon!=null){ if(pushPoint(lon,lat,props)) continue; }
          const coord=row.coordinates??row.Coordinates??row.coord??row.Coord;
          if(typeof coord==='string' && coord.includes(',')){
            const [a,b]=coord.split(',').map(s=>s.trim());
            if(pushPoint(a,b,props)) continue;
            if(pushPoint(b,a,props)) continue;
          }
        }
      }

      if(!norm.length) throw new Error('No valid point features found in places.geojson.');
      const gj={ type:'FeatureCollection', features:norm };

      if (map.getLayer(GEO_LAYER_ID)) map.removeLayer(GEO_LAYER_ID);
      if (map.getSource(GEO_SOURCE_ID)) map.removeSource(GEO_SOURCE_ID);

      map.addSource(GEO_SOURCE_ID,{ type:'geojson', data:gj });
      map.addLayer({
        id:GEO_LAYER_ID, type:'circle', source:GEO_SOURCE_ID,
        paint:{ 'circle-radius':6,'circle-color':'#2563eb','circle-stroke-color':'#fff','circle-stroke-width':1,'circle-opacity':1 }
      });

      // Put points on top
      try { map.moveLayer(GEO_LAYER_ID); } catch {}

      // Fit to points
      try{
        const b=turf.bbox(gj);
        if(b&&isFinite(b[0])&&b[0]!==b[2]&&b[1]!==b[3]){
          map.fitBounds([[b[0],b[1]],[b[2],b[3]]],{ padding:60, duration:600 });
        }
      }catch{}

      // Popups
      map.on('click', GEO_LAYER_ID, e=>{
        const p=e.features[0].properties||{}; const ll=e.features[0].geometry.coordinates;
        const g=k=> (p[k]?String(p[k]):'');
        const lines=[
          `<strong>${g('Name')||g('name')||'Place'}</strong>`,
          g('Type') && `<div><em>${g('Type')}</em></div>`,
          (g('City')||g('State')) && `${g('City')}${g('City')&&g('State')?', ':''}${g('State')}`,
          g('Notes') && `<div style="margin-top:6px">${g('Notes')}</div>`,
          g('URL') && `<div style="margin-top:6px"><a href="${g('URL')}" target="_blank" rel="noopener">Open link</a></div>`
        ].filter(Boolean);
        new mapboxgl.Popup().setLngLat(ll).setHTML(lines.join('<br>')).addTo(map);
      });
      map.on('mouseenter', GEO_LAYER_ID, ()=> map.getCanvas().style.cursor='pointer');
      map.on('mouseleave', GEO_LAYER_ID, ()=> map.getCanvas().style.cursor='');

      // Legend
      document.getElementById('legend').innerHTML = `
        <b>Legend</b><br>
        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#2563eb;margin-right:6px"></span>Place<br>
        <span style="display:inline-block;width:10px;height:10px;background:#7c3aed;margin-right:6px"></span>Reachable area
      `;

      // Map is ready; enable controls
      mapReady=true;
      maybeEnableApply();
      clearBtn.disabled=false;

      // Keep a live count
      function updateVisibleCount(){
        try{ visOut.textContent=String(map.queryRenderedFeatures({layers:[GEO_LAYER_ID]}).length); }
        catch{ visOut.textContent='n/a'; }
      }
      updateVisibleCount();
      map.on('moveend', updateVisibleCount);

    }catch(e){ showErr(e.message||String(e)); console.error(e); }
  });

  // ===== Helpers =====
  async function geocodeQuery(q){
    const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json`);
    url.searchParams.set('access_token', mapboxgl.accessToken);
    url.searchParams.set('limit','1');
    const r = await fetch(url.toString());
    if(!r.ok) throw new Error(`Geocode ${r.status}`);
    const j = await r.json();
    const f = j.features?.[0];
    if(!f?.center) throw new Error('No results for that location.');
    return {lng:f.center[0], lat:f.center[1]};
  }

  async function fetchIso(lng,lat,minutes,profile){
    const url=new URL(`https://api.mapbox.com/isochrone/v1/mapbox/${profile}/${lng},${lat}`);
    url.searchParams.set('contours_minutes',String(minutes));
    url.searchParams.set('polygons','true');
    url.searchParams.set('denoise','1');
    url.searchParams.set('generalize','10');
    url.searchParams.set('access_token',mapboxgl.accessToken);
    const res=await fetch(url.toString());
    if(!res.ok) throw new Error(`Isochrone ${res.status}: ${await res.text().catch(()=>res.statusText)}`);
    return await res.json();
  }

  async function buildRouteCorridor(line,minutes,profile){
    const lineKm=turf.length(line,{units:'kilometers'});
    if(!isFinite(lineKm)||lineKm<=0) throw new Error('Route length is zero.');
    const r_km=(AVG_SPEED_KMH[profile]||65)*(minutes/60);
    let spacingKm=Math.max(0.5*r_km,1);
    let count=Math.ceil(lineKm/spacingKm);
    if(count>MAX_SAMPLES_HARD){ count=MAX_SAMPLES_HARD; spacingKm=lineKm/count; }
    const samples=[];
    for(let i=0;i<=count;i++){
      const d=Math.min(i*spacingKm,lineKm);
      const pt=turf.along(line,d,{units:'kilometers'});
      samples.push(pt.geometry.coordinates);
    }
    samples[samples.length-1]=line.coordinates[line.coordinates.length-1];
    let unionGeom=null;
    for(let i=0;i<samples.length;i++){
      const [lng,lat]=samples[i];
      const gj=await fetchIso(lng,lat,minutes,profile);
      const feat=gj.features?.[0];
      if(!feat) continue;
      unionGeom = unionGeom
        ? turf.union({type:'Feature',geometry:unionGeom,properties:{}}, feat)?.geometry || unionGeom
        : feat.geometry;
    }
    if(!unionGeom) throw new Error('Failed to build isochrone corridor.');
    return unionGeom;
  }

  function ensureIsoReady(){
    if (!map.getSource(ISO_SOURCE_ID) || !map.getLayer(ISO_LAYER_FILL) || !map.getLayer(ISO_LAYER_LINE)){
      ensureIsoLayers();
    }
  }

  function applyIsoFilter(featureOrNull){
    if(!map.getLayer(GEO_LAYER_ID)) return;
    if(featureOrNull){
      const lit=['literal',featureOrNull];
      map.setFilter(GEO_LAYER_ID,['all',['within',lit]]);
      map.setPaintProperty(GEO_LAYER_ID,'circle-opacity',['case',['within',lit],1,0.2]);
    }else{
      map.setFilter(GEO_LAYER_ID,null);
      map.setPaintProperty(GEO_LAYER_ID,'circle-opacity',1);
    }
  }

  // ===== Apply / Clear =====
  applyBtn.addEventListener('click', async ()=>{
    clearErr();
    if (!mapReady){ showErr('Map is still loading.'); return; }

    // make sure iso source/layers exist now
    ensureIsoReady();

    const minutes=Number(minsInput.value||15);
    const profile=(document.querySelector('input[name="mode"]:checked')?.value||'driving');

    try{
      if(currentUXMode()==='point'){
        const originInput = singleMount.querySelector('.mapbox-directions-origin input[type="text"]');
        if(!originInput || !originInput.value.trim()) throw new Error('Enter a Location.');
        const o = await geocodeQuery(originInput.value.trim());
        const gj=await fetchIso(o.lng,o.lat,minutes,profile);
        const feat=gj.features?.[0]; if(!feat) throw new Error('No isochrone returned.');
        currentIsoFeature=feat;
      }else{
        // Gather active route
        let line = currentRouteLine;
        if(!line){
          // fallback: try to read from plugin source
          try{
            const src=map.getSource('directions');
            const data=src && (src._data || (src.serialize && src.serialize().data));
            if(data?.features?.length){
              const all=[];
              for(const f of data.features){
                if(!f.geometry) continue;
                if(f.geometry.type==='LineString' && f.geometry.coordinates?.length>1) all.push(...f.geometry.coordinates);
                else if(f.geometry.type==='MultiLineString' && Array.isArray(f.geometry.coordinates)){
                  for(const seg of f.geometry.coordinates) if(Array.isArray(seg)&&seg.length>1) all.push(...seg);
                }
              }
              if(all.length>1) line = { type:'LineString', coordinates:all };
            }
          }catch{}
        }
        if(!line) throw new Error('Enter start and destination and wait for the route to draw.');

        const corridorGeom=await buildRouteCorridor(line,minutes,profile);
        currentIsoFeature={ type:'Feature', geometry:corridorGeom, properties:{} };
      }

      // Now set data safely
      const isoSrc = map.getSource(ISO_SOURCE_ID);
      if(!isoSrc) throw new Error('Isochrone source missing.');
      isoSrc.setData({ type:'FeatureCollection', features:[currentIsoFeature] });

      applyIsoFilter(currentIsoFeature);

      const bbox=turf.bbox(currentIsoFeature);
      if((fitToggle.checked || !hasFitOnce) && bbox && isFinite(bbox[0])){
        map.fitBounds([[bbox[0],bbox[1]],[bbox[2],bbox[3]]],{ padding:50, duration:600 });
        hasFitOnce=true;
      }
    }catch(e){ showErr(e.message||String(e)); console.error(e); }
  });

  clearBtn.addEventListener('click', ()=>{
    clearErr(); currentIsoFeature=null; hasFitOnce=false;
    ensureIsoReady();
    const isoSrc = map.getSource(ISO_SOURCE_ID);
    if (isoSrc) isoSrc.setData({ type:'FeatureCollection', features:[] });
    applyIsoFilter(null);
    try{ singleDir.setOrigin(''); }catch{}
    try{ routeDir.setOrigin(''); routeDir.setDestination(''); }catch{}
    const originInput = singleMount.querySelector('.mapbox-directions-origin input[type="text"]');
    if (originInput) originInput.value='';
    maybeEnableApply();
  });

})();
</script>
</body>
</html>
