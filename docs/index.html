<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Didius Travel Map â€” Robust Points + Inputs-only Directions</title>

<link href="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.13.0/mapbox-gl.js"></script>

<link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.3.1/mapbox-gl-directions.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<style>
  html,body{height:100%;margin:0;font-family:system-ui,Inter,Arial}
  #map{height:100vh;width:100%}
  .panel{position:absolute;z-index:3;left:12px;top:12px;background:#fff;padding:10px 12px;border-radius:12px;border:1px solid #e5e7eb;box-shadow:0 6px 20px rgba(0,0,0,.12);display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .panel label{font-size:12px;color:#111827}
  .panel input[type="range"]{width:160px}
  .pill{border:1px solid #e5e7eb;border-radius:999px;padding:4px 10px;font-size:12px;background:#f8fafc;cursor:pointer}
  #legend{position:absolute;right:12px;top:12px;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.12);z-index:2}
  #err{position:absolute;left:12px;bottom:12px;background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:8px 10px;box-shadow:0 6px 20px rgba(0,0,0,.12);font-size:12px;max-width:70ch;display:none;z-index:4;white-space:pre-wrap}
  #dbg{position:absolute;right:12px;bottom:12px;background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:6px 8px;font-size:12px;z-index:4}
  .mapboxgl-ctrl-top-right{margin-top:8px}
  button:disabled{opacity:.5;cursor:not-allowed}
</style>
</head>
<body>

<div class="panel">
  <span class="pill" style="background:#fff">Within 
    <input id="mins" type="range" min="5" max="60" step="5" value="15" />
    <strong><span id="minsVal">15</span> min</strong>
  </span>
  <span class="pill" style="background:#fff">
    Mode:
    <label><input type="radio" name="mode" value="driving" checked> Driving</label>
    <label><input type="radio" name="mode" value="walking"> Walking</label>
    <label><input type="radio" name="mode" value="cycling"> Cycling</label>
  </span>
  <button id="applyIso" class="pill" disabled>Apply to route</button>
  <button id="clearIso" class="pill">Clear</button>
  <label class="pill" style="background:#fff">
    <input id="fitToggle" type="checkbox" />
    Fit view to corridor
  </label>
</div>

<div id="map" aria-label="Interactive map"></div>
<div id="legend"></div>
<div id="err"></div>
<div id="dbg">Visible points: <span id="visCount">0</span></div>

<script>
// ====== CONFIG ======
mapboxgl.accessToken = 'pk.eyJ1IjoiYnJhZDEzbWFydGluIiwiYSI6ImNta2p6eHI5MzE4YzAzY282aXE4Mjhxc3QifQ.tkosuQGdRkfSMoRVWCakbg';
const STYLE_URL = 'mapbox://styles/brad13martin/cmkjztnvs001u01qm6lsmeold';

// index.html is in /docs and GeoJSON is under /docs/data
const GEO_PATH  = 'data/places.geojson';

const GEO_SOURCE_ID = 'places-geo';
const GEO_LAYER_ID  = 'places-geo-points';
const ISO_SOURCE_ID = 'iso-source';
const ISO_LAYER_FILL = 'iso-fill';
const ISO_LAYER_LINE = 'iso-line';

const MAX_SAMPLES = 12;
const AVG_SPEED_KMH = { driving: 65, walking: 5, cycling: 18 };

// ====== UI refs ======
const minsInput = document.getElementById('mins');
const minsVal   = document.getElementById('minsVal');
const applyBtn  = document.getElementById('applyIso');
const clearBtn  = document.getElementById('clearIso');
const fitToggle = document.getElementById('fitToggle');
const errBox    = document.getElementById('err');
const visOut    = document.getElementById('visCount');

minsInput.addEventListener('input', () => minsVal.textContent = minsInput.value);
function showErr(msg){ errBox.style.display='block'; errBox.textContent = msg; }
function clearErr(){ errBox.style.display='none'; errBox.textContent=''; }

let routeReady = false;
function setApplyEnabled(on){ routeReady = !!on; applyBtn.disabled = !on; }

// Track user interactions to avoid refitting while they move the map
let userInteracting = false;
let hasFitOnce = false;

// ====== MAP ======
const map = new mapboxgl.Map({
  container: 'map',
  style: STYLE_URL,
  center: [-80, 40],
  zoom: 5
});
map.addControl(new mapboxgl.NavigationControl());
map.on('error', ev => showErr('Mapbox: ' + (ev?.error?.message || JSON.stringify(ev))));

['dragstart','zoomstart','rotatestart','pitchstart'].forEach(ev =>
  map.on(ev, () => { userInteracting = true; })
);
['dragend','zoomend','rotateend','pitchend'].forEach(ev =>
  map.on(ev, () => { userInteracting = false; })
);

// ====== DIRECTIONS (inputs-only) ======
const directions = new MapboxDirections({
  accessToken: mapboxgl.accessToken,
  profile: 'mapbox/driving',
  unit: 'imperial',
  alternatives: true,
  controls: { instructions: true, inputs: true, profileSwitcher: true },
  interactive: false,  // disable map clicks to set A/B
  draggable: false,    // disable dragging A/B pins
  geometries: 'geojson'
});
map.addControl(directions, 'top-right');

// Safety net: if the plugin ever enters placing mode, block map click from propagating
map.on('click', (e) => {
  const box = document.querySelector('.mapboxgl-ctrl-directions');
  const placing = box && (box.classList.contains('is-placing') || box.classList.contains('directions-placing'));
  if (placing) e.originalEvent.stopImmediatePropagation();
});

let currentRouteLine = null;

// Primary route capture: event
directions.on('route', e => {
  try {
    const r = e?.route?.[0];
    if (r?.geometry?.type === 'LineString') {
      currentRouteLine = r.geometry;
    } else if (r?.geometry?.coordinates) {
      currentRouteLine = { type:'LineString', coordinates: r.geometry.coordinates };
    } else {
      currentRouteLine = null;
    }
    setApplyEnabled(!!currentRouteLine?.coordinates?.length);
    // do not auto-apply
    hasFitOnce = false;
  } catch { currentRouteLine = null; setApplyEnabled(false); }
});

// Robust getter: 1) stored geometry, 2) read 'directions' source if present
function getActiveRouteLine() {
  if (currentRouteLine?.coordinates?.length) return currentRouteLine;
  try {
    const src = map.getSource('directions');
    const data = src && (src._data || (src.serialize && src.serialize().data));
    if (data && data.features && data.features.length) {
      const line = data.features.find(f => f.geometry && f.geometry.type === 'LineString' && f.geometry.coordinates?.length > 1);
      if (line) return { type:'LineString', coordinates: line.geometry.coordinates };
      const mline = data.features.find(f => f.geometry && f.geometry.type === 'MultiLineString');
      if (mline && mline.geometry.coordinates?.length) {
        return { type:'LineString', coordinates: mline.geometry.coordinates[0] };
      }
    }
  } catch {}
  return null;
}

// Secondary route capture: when 'directions' source updates
map.on('sourcedata', e => {
  if (e.sourceId !== 'directions' || !map.isSourceLoaded('directions')) return;
  const line = getActiveRouteLine();
  setApplyEnabled(!!line?.coordinates?.length);
  // do not auto-apply
});

// ====== LOAD LAYERS ======
map.on('load', async () => {
  // Isochrone shells
  map.addSource(ISO_SOURCE_ID, { type: 'geojson', data: { type:'FeatureCollection', features: [] } });
  map.addLayer({ id: ISO_LAYER_FILL, type: 'fill', source: ISO_SOURCE_ID,
    paint: { 'fill-color': '#7c3aed', 'fill-opacity': 0.18 } });
  map.addLayer({ id: ISO_LAYER_LINE, type: 'line', source: ISO_SOURCE_ID,
    paint: { 'line-color': '#5b21b6', 'line-width': 2.5, 'line-opacity': 0.9 } });

  // Keep corridor under points
  map.moveLayer(ISO_LAYER_FILL);
  map.moveLayer(ISO_LAYER_LINE);

  // GeoJSON points with robust normalization
  try {
    console.log('Fetching GeoJSON from:', GEO_PATH);
    const resp = await fetch(GEO_PATH, { cache: 'no-store' });
    console.log('GeoJSON HTTP status:', resp.status);
    if (!resp.ok) throw new Error(`Fetch failed: ${resp.status} ${resp.statusText}`);
    const raw = await resp.json();

    let feats = [];
    if (raw && raw.type === 'FeatureCollection' && Array.isArray(raw.features)) {
      console.log(`Loaded ${raw.features.length} raw features`);
      feats = raw.features;
    } else if (Array.isArray(raw)) {
      console.warn('Top-level is an array, wrapping as FeatureCollection');
      feats = raw;
    } else {
      throw new Error('Unrecognized data format. Expected FeatureCollection or array of features.');
    }

    // Normalize to true Point features with numeric [lng, lat]
    const norm = [];
    for (const f of feats) {
      let props = f.properties || {};
      // Use Point geometry if valid
      if (f.geometry && f.geometry.type === 'Point' && Array.isArray(f.geometry.coordinates)) {
        let [x, y] = f.geometry.coordinates;
        x = Number(x); y = Number(y);
        if (Number.isFinite(x) && Number.isFinite(y)) {
          if (Math.abs(x) <= 90 && Math.abs(y) > 90) [x, y] = [y, x];
          norm.push({ type:'Feature', geometry:{ type:'Point', coordinates:[x, y] }, properties: props });
          continue;
        }
      }
      // Build from Lat/Long properties if present
      const lat = Number(props.Lat ?? props.lat ?? props.latitude ?? props.Latitude);
      const lon = Number(props.Long ?? props.long ?? props.lng ?? props.Lng ?? props.longitude ?? props.Longitude);
      if (Number.isFinite(lat) && Number.isFinite(lon)) {
        let x = lon, y = lat;
        if (Math.abs(x) <= 90 && Math.abs(y) > 90) [x, y] = [y, x];
        norm.push({ type:'Feature', geometry:{ type:'Point', coordinates:[x, y] }, properties: props });
      }
    }

    if (!norm.length) {
      console.error('No valid points after normalization. First few raw features:', feats.slice(0,3));
      throw new Error('No valid point features found. Check coordinates are numbers in [lon, lat] or that Lat and Long properties exist.');
    }

    const gj = { type:'FeatureCollection', features: norm };
    console.log(`Normalized to ${gj.features.length} Point features`);

    map.addSource(GEO_SOURCE_ID, { type: 'geojson', data: gj });
    map.addLayer({
      id: GEO_LAYER_ID, type: 'circle', source: GEO_SOURCE_ID,
      paint: {
        'circle-radius': 6,
        'circle-color': '#2563eb',
        'circle-stroke-color': '#fff',
        'circle-stroke-width': 1,
        'circle-opacity': 1
      }
    });

    // Fit to points once so they are visible initially
    try {
      const b = turf.bbox(gj);
      if (b && isFinite(b[0]) && isFinite(b[2]) && b[0] !== b[2] && b[1] !== b[3]) {
        map.fitBounds([[b[0], b[1]], [b[2], b[3]]], { padding: 60, duration: 600 });
      }
    } catch {}

    // Popups
    map.on('click', GEO_LAYER_ID, e => {
      const p = e.features[0].properties || {};
      const ll = e.features[0].geometry.coordinates;
      const g = k => (p[k] ? String(p[k]) : '');
      const lines = [
        `<strong>${g('Name') || 'Place'}</strong>`,
        g('Type') && `<div><em>${g('Type')}</em></div>`,
        (g('City') || g('State')) && `${g('City')}${g('City')&&g('State')?', ':''}${g('State')}`,
        g('Notes') && `<div style="margin-top:6px">${g('Notes')}</div>`,
        g('URL') && `<div style="margin-top:6px"><a href="${g('URL')}" target="_blank" rel="noopener">Open link</a></div>`
      ].filter(Boolean);
      new mapboxgl.Popup().setLngLat(ll).setHTML(lines.join('<br>')).addTo(map);
    });
    map.on('mouseenter', GEO_LAYER_ID, () => map.getCanvas().style.cursor = 'pointer');
    map.on('mouseleave', GEO_LAYER_ID, () => map.getCanvas().style.cursor = '');

    // Legend
    document.getElementById('legend').innerHTML = `
      <b>Legend</b><br>
      <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#2563eb;margin-right:6px"></span>Place<br>
      <span style="display:inline-block;width:10px;height:10px;background:#7c3aed;margin-right:6px"></span>Reachable area
    `;

    // Init count + update on pan/zoom
    updateVisibleCount();
    map.on('moveend', updateVisibleCount);

  } catch (e) {
    showErr('Could not load data/places.geojson or parse points. Open console for details.');
    console.error(e);
  }
});

// ====== ISOCHRONE HELPERS ======
async function fetchIso(lng, lat, minutes, profile){
  const url = new URL(`https://api.mapbox.com/isochrone/v1/mapbox/${profile}/${lng},${lat}`);
  url.searchParams.set('contours_minutes', String(minutes));
  url.searchParams.set('polygons', 'true');
  url.searchParams.set('denoise', '1');
  url.searchParams.set('generalize', '10');
  url.searchParams.set('access_token', mapboxgl.accessToken);
  const res = await fetch(url.toString());
  if (!res.ok) throw new Error(`Isochrone ${res.status}: ${await res.text().catch(()=>res.statusText)}`);
  return await res.json();
}

async function buildRouteCorridor(line, minutes, profile){
  if (!line?.coordinates || line.coordinates.length < 2) {
    throw new Error('No route geometry yet. Enter start and destination, then wait for the blue route line.');
  }
  const lineKm = turf.length(line, { units:'kilometers' });
  if (!isFinite(lineKm) || lineKm <= 0) throw new Error('Route length is zero.');

  const r_km = (AVG_SPEED_KMH[profile] || 65) * (minutes/60);
  let spacing = Math.max(0.75 * r_km, 1);
  let count = Math.ceil(lineKm / spacing);
  if (count > MAX_SAMPLES) { count = MAX_SAMPLES; spacing = lineKm / count; }

  const samples = [];
  for (let i = 0; i <= count; i++) {
    const d = Math.min(i * spacing, lineKm);
    const pt = turf.along(line, d, { units:'kilometers' });
    samples.push(pt.geometry.coordinates);
  }

  let unionGeom = null;
  for (let i = 0; i < samples.length; i++) {
    const [lng, lat] = samples[i];
    const gj = await fetchIso(lng, lat, minutes, profile);
    const feat = gj.features?.[0];
    if (!feat) continue;
    unionGeom = unionGeom
      ? turf.union({ type:'Feature', geometry: unionGeom, properties:{} }, feat)?.geometry || unionGeom
      : feat.geometry;
  }
  if (!unionGeom) throw new Error('Failed to build isochrone corridor.');
  return unionGeom;
}

// ====== FILTERING ======
let currentIsoFeature = null;

function updateVisibleCount(){
  try {
    const vis = map.queryRenderedFeatures({ layers:[GEO_LAYER_ID] }).length;
    visOut.textContent = String(vis);
  } catch { visOut.textContent = 'n/a'; }
}

function applyIsoFilter(featureOrNull){
  if (!map.getLayer(GEO_LAYER_ID)) return;
  if (featureOrNull) {
    const lit = ['literal', featureOrNull];
    map.setFilter(GEO_LAYER_ID, ['all', ['within', lit]]);
    map.setPaintProperty(GEO_LAYER_ID, 'circle-opacity', ['case', ['within', lit], 1, 0]);
  } else {
    map.setFilter(GEO_LAYER_ID, null);
    map.setPaintProperty(GEO_LAYER_ID, 'circle-opacity', 1);
  }
  updateVisibleCount();
}

// ====== APPLY ======
async function applyIsoFromCurrentControls() {
  clearErr();
  const line = getActiveRouteLine();
  if (!line) throw new Error('No route yet. Enter start and destination, then wait for the blue route line.');
  const minutes = Number(minsInput.value || 15);
  const mode = (document.querySelector('input[name="mode"]:checked')?.value || 'driving');

  const corridorGeom = await buildRouteCorridor(line, minutes, mode);
  currentIsoFeature = { type:'Feature', geometry:corridorGeom, properties:{} };

  map.getSource(ISO_SOURCE_ID).setData({ type:'FeatureCollection', features:[ currentIsoFeature ] });
  applyIsoFilter(currentIsoFeature);

  // Fit only if requested and not while interacting
  if (!userInteracting && (fitToggle.checked || !hasFitOnce)) {
    const bbox = turf.bbox(currentIsoFeature);
    if (bbox && isFinite(bbox[0])) {
      map.fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { padding: 50, duration: 600 });
      hasFitOnce = true;
    }
  }
}

// Recompute corridor if you change minutes and a route is ready
minsInput.addEventListener('change', () => {
  if (routeReady) applyIsoFromCurrentControls().catch(console.error);
});

// ====== BUTTONS ======
applyBtn.addEventListener('click', async () => {
  try {
    if (!routeReady) throw new Error('Enter a start and destination first. The Apply button enables when the route is ready.');
    await applyIsoFromCurrentControls();
  } catch (e) {
    showErr(e.message || String(e));
    console.error(e);
  }
});

clearBtn.addEventListener('click', () => {
  clearErr();
  currentIsoFeature = null;
  if (map.getSource(ISO_SOURCE_ID)) {
    map.getSource(ISO_SOURCE_ID).setData({ type:'FeatureCollection', features: [] });
  }
  applyIsoFilter(null);
  hasFitOnce = false;
});
</script>
</body>
</html>
